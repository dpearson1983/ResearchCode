/* LNPk-PP.cpp
 * David W. Pearson
 * November 7, 2016
 * 
 * This code will be used to calculate the power spectrum from the plane-parallel mocks for
 * the wide field DESI BSG study. The mocks this code will process have had the anisotropy
 * induced such that it is only in one specific coordinate direction (the x direction) using
 * the velocities generated by LNKNLogs. In this way, we should be able to get a good estimate
 * of what the power spectrum should be from the mocks which have radial anisotropies since
 * the velocities used where generated in the same way.
 */

#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <cstring>
#include <vector>
#include <cmath>
#include <fftw3.h>
#include <omp.h>
#include <harppi.h>
#include <fileFuncs.h>
#include <pfunk.h>
#include <pods.h>

int main(int argc, char *argv[]) {
    // Read parameters from file using harppi
    parameters p(argv[1]);
    p.print();
    
    // Declare input and output file streams
    std::ifstream fin;
    std::ofstream fout;
    
    // Determine the number randoms in the file
    long int randomsSize = filesize(p.gets("randomsFile"));
    std::cout << "Randoms file size: " << randomsSize << std::endl;
    std::cout << "galaxy size: " << sizeof(galaxy) << std::endl;
    int numRans = randomsSize/sizeof(galaxy);
    std::cout << "Number of Randoms: " << numRans << std::endl;
    
    // Allocate memory to read in the randoms. Use a pointer so that memory can
    // be freed after randoms are binned.
    galaxy *rans = new galaxy[numRans];
    
    // Read in the randoms
    fin.open(p.gets("randomsFile").c_str(), std::ios::in|std::ios::binary);
    fin.read((char *) rans, numRans*sizeof(galaxy));
    fin.close();
    
    // Setup some convenience variables
    int3 N = {p.geti("Nx"), p.geti("Ny"), p.geti("Nz")};
    int N_r = N.x*N.y*N.z;
    int N_k = N.x*N.y*(N.z/2 + 1);
    double3 L = {p.getd("Lx"), p.getd("Ly"), p.getd("Lz")};
    double3 dr = {L.x/double(N.x), L.y/double(N.y), L.z/double(N.z)};
    
    // Declare memory to store the binned randoms info and initialize to zero
    std::vector<double> nden_ran;
    nden_ran.reserve(N_r);
    initArray(&nden_ran[0], N_r);
    int corrType = 0;
    
    double V_ran = 0.0;
    // Bin the randoms using either nearest grid point (NGP) or cloud-in-cell (CIC).
    // Default is to use NGP if not specified in parameter file.
    std::cout << "Assigning randoms to the grid..." << std::endl;
    if (p.gets("massAssign") == "NGP" || !p.checkParam("massAssign")) {
        V_ran = binNGP(rans, &nden_ran[0], dr, numRans, N);
    } else if (p.gets("massAssign") == "CIC") {
        V_ran = binCIC(rans, &nden_ran[0], dr, numRans, N);
        corrType = 1;
    } else {
        std::stringstream message;
        message << "ERROR: " << p.gets("massAssign") << " is not a supported mass assignment\n";
        message << "scheme. The supported ones are NGP or CIC. Please correct the parameter\n";
        message << "file and rerun the code.\n";
        throw std::runtime_error(message.str());
    }
    double nbar_ran = double(numRans)/V_ran;
    
    // Free memory for reading in the randoms file.
    delete[] rans;
    
    int numThreads = 0;
    if (p.checkParam("numThreads")) {
        numThreads = p.geti("numThreads");
    } else {
        numThreads = omp_get_max_threads();
    }
    
    // Setup for the FFTs
    fftw_init_threads();
    double *dr3d = new double[N_r];
    fftw_complex *dk3d = new fftw_complex[N_k];
    
    fftw_import_wisdom_from_filename("FFTWWisdom.dat");
    fftw_plan_with_nthreads(numThreads);
    fftw_plan dr3d2dk3d = fftw_plan_dft_r2c_3d(N.x, N.y, N.z, dr3d, dk3d, FFTW_MEASURE);
    fftw_export_wisdom_to_filename("FFTWWisdom.dat");
    
    // Loop through all the mocks the user wishes to process specified by the values
    // of startNum and numMocks in the parameter file. HARPPI will throw an error if those
    // values are not present.
    for (int mock = p.geti("startNum"); mock < p.geti("numMocks")+p.geti("startNum"); ++mock) {
        // Dynamically get file names for input and output.
        std::string ifile = filename(p.gets("iBase"), p.geti("digits"), mock, p.gets("iExt"));
        std::string ofile = filename(p.gets("oBase"), p.geti("digits"), mock, p.gets("oExt"));
        
        std::cout << "Processing " << ifile << "..." << std::endl;
        
        long int galaxiesSize = filesize(ifile);
        int numGals = galaxiesSize/sizeof(galaxy);
        std::cout << "    Number of Galaxies: " << numGals << std::endl;
        
        std::cout << "    Allocating memory to read in galaxies..." << std::endl;
        galaxy *gals = new galaxy[numGals];
        
        std::cout << "    Reading in galaxies..." << std::endl;
        fin.open(ifile, std::ios::in|std::ios::binary);
        fin.read((char *) gals, numGals*sizeof(galaxy));
        fin.close();
        
        std::cout << "    Binning galaxies..." << std::endl;
        std::vector<double> nden_gal;
        nden_gal.reserve(N_r);
        initArray(&nden_gal[0], N_r);
        
        double V = 0.0;
        if (p.gets("massAssign") == "NGP" || !p.checkParam("massAssign")) {
            V = binNGP(gals, &nden_gal[0], dr, numGals, N);
        } else if (p.gets("massAssign") == "CIC") {
            V = binCIC(gals, &nden_gal[0], dr, numGals, N);
        }
        
        delete[] gals;
        
        double nbar = double(numGals)/V;
        double alpha = double(numGals)/double(numRans);
        double shotnoise = double(numGals) + alpha*alpha*double(numRans);
        double gal_nbsqwsq = alpha*double(numRans)*nbar;
        
        std::cout << "    nbar = " << nbar << std::endl;
        std::cout << "    alpha = " << alpha << std::endl;
        std::cout << "    1/nbar = " << 1.0/nbar << std::endl;
        std::cout << "    shotnoise = " << shotnoise/gal_nbsqwsq << std::endl;
        std::cout << "    gal_nbsqwsq = " << gal_nbsqwsq << std::endl;
        
        std::cout << "    Zeroing arrays for the FFT..." << std::endl;
        initArray(dr3d, dk3d, N_r, N_k);
        
        // Calculate delta_r
        std::cout << "    Calculating delta(r) from binned galaxies and randoms..." << std::endl;
        for (int i = 0; i < N_r; ++i) {
            dr3d[i] = nden_gal[i] - alpha*nden_ran[i];
        }
        
        // Peform FFT
        std::cout << "    Performing FFT..." << std::endl;
        fftw_execute(dr3d2dk3d);
        
        // Bin Frequencies
        std::cout << "    Binning frequencies..." << std::endl;
        std::vector<double> P_0(p.geti("numKBins"));
        std::vector<double> P_2(p.geti("numKBins"));
        std::vector<double> P_2shot(p.geti("numKBins"));
        std::vector<int> N_0(p.geti("numKBins"));
        freqBinPP(dk3d, &P_0[0], &P_2[0], &P_2shot[0], &N_0[0], N, L, shotnoise, p.getd("k_min"), 
                  p.getd("k_max"), p.geti("numKBins"), p.getb("grid_cor"), corrType);
        
        // Normalize and output
        normalizePk(&P_0[0], &P_2[0], &P_2shot[0], &N_0[0], gal_nbsqwsq, p.geti("numKBins"));
        if (p.getb("discreteCor")) {
            correct_discreteness(p.gets("cor_file"), &P_0[0], &P_2[0], p.geti("numKBins"));
        }
        double dk = (p.getd("k_max") - p.getd("k_min"))/p.getd("numKBins");
        fout.open(ofile.c_str(), std::ios::out);
        fout.precision(15);
        for (int i = 0; i < p.geti("numKBins"); ++i) {
            double k = p.getd("k_min") + (i + 0.5)*dk;
            fout << k << " " << P_0[i] << "\n";
        }
        for (int i = 0; i < p.geti("numKBins"); ++i) {
            double k = p.getd("k_min") + (i + 0.5)*dk;
            fout << k << " " << P_2[i] << "\n";
        }
        fout.close();
    }
    
    delete[] dr3d;
    delete[] dk3d;
    fftw_destroy_plan(dr3d2dk3d);
    
    return 0;
}
